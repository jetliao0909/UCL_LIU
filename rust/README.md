# 肥米輸入法 - Rust 版本 MVP

這是肥米輸入法的 Rust 重寫版本，目前處於 MVP（最小可行產品）階段。

## 功能狀態

### ✅ 已實現
- [x] 專案結構設置
- [x] 基本模組架構
- [x] 字碼表載入（JSON 格式，大小寫不區分）
- [x] Windows 低階鍵盤鉤子
- [x] 字根輸入處理（A-Z，自動轉為小寫）
- [x] 候選字查詢和選擇（數字鍵 0-9）
- [x] 特殊按鍵處理（Backspace、Space、Enter、ESC）
- [x] Shift 鍵切換攔截模式
- [x] F4 鍵退出功能
- [x] 系統托盤退出選項（與 F4 鍵行為一致）
- [x] 鍵盤輸入模擬（剪貼簿貼上模式）
- [x] 系統托盤圖示框架
- [x] 單一實例鎖定機制（使用文件鎖定防止重複執行）
- [x] 單元測試覆蓋

### 🚧 進行中
- [ ] GUI 介面（候選字視窗）
- [ ] 模式） 

### 📋 待實現
- [ ] 配置檔案讀寫（INI 格式）
- [ ] 同音字功能
- [ ] 簡繁轉換
- [ ] 自定詞庫
- [ ] 打字音效
- [ ] 特殊應用程式處理（putty、notepad 等）

## 編譯要求

- Rust 1.70+ 
- Windows SDK（Windows 10 SDK 或更高版本推薦）
- Visual Studio Build Tools（用於編譯 Windows crates）

## Windows 版本支援

- ✅ **Windows 10** - 完全支援並測試
- ✅ **Windows 11** - 完全支援並測試
- ⚠️ **Windows 7** - 理論支援，但未充分測試（已停止支援）

詳細的兼容性說明請參考 [WINDOWS_COMPATIBILITY.md](WINDOWS_COMPATIBILITY.md)

## 編譯指令

```bash
cd rust
cargo build --release
```

## 執行

編譯後的可執行檔位於 `target/release/uclliu.exe`

需要準備：
- `liu.json` - 字碼表檔案（**必須**與執行檔放在同一目錄）
- `pinyi.txt` - 同音字表（可選，與執行檔同目錄）

**注意**：字典檔必須與執行檔放在同一目錄，程式不會從其他位置載入字典檔。

### 單一實例鎖定

程序啟動時會創建 `UCLLIU.lock` 文件並獲取獨占鎖，以防止重複執行：

**為什麼需要文件？**
- 文件鎖定機制需要一個實際的文件對象作為載體
- `fs2::FileExt::try_lock_exclusive()` 是對文件句柄的操作，必須先打開文件才能鎖定
- 鎖是附加在文件句柄上的，不是文件名；當句柄關閉時，鎖會自動釋放
- 文件內容不重要，文件只是鎖的載體

**工作原理：**
- 如果已有實例在運行，新實例會檢測到鎖已被持有，並立即退出
- 當程序正常退出時，文件鎖會自動釋放（文件句柄被 drop）
- 如果程序異常退出，文件鎖也會由操作系統自動釋放
- 程序退出時會自動刪除 `UCLLIU.lock` 文件（清理殘留文件）

## 開發筆記

### 鍵盤鉤子實作注意事項

Windows 鍵盤鉤子回調函數是靜態函數，無法直接訪問實例變數。需要使用以下方式之一：
1. 使用 thread_local 存儲狀態
2. 使用全域變數（Arc<Mutex<>>）
3. 使用 Windows 的 SetWindowLongPtr 存儲指標

### 已實現功能說明

1. **字根輸入處理**
   - 支援 A-Z 字母鍵輸入
   - 自動轉為小寫（字根查詢時大小寫無分別）
   - 最多 5 碼字根

2. **候選字選擇**
   - 數字鍵 0-9 選擇候選字
   - Space 鍵：選擇第一個候選字並清除輸入
   - Enter 鍵：選擇第一個候選字並清除輸入（與 Space 行為一致）
   - **補碼機制**：
     - 輸入 `v`：如果當前字根 + `v` 不在字典中，但當前字根存在且候選字數量 >= 2，則選擇候選2（第2個候選字），等待 Space 鍵送出
     - 輸入 `r`：如果當前字根 + `r` 不在字典中，但當前字根存在且候選字數量 >= 3，則選擇候選3（第3個候選字），等待 Space 鍵送出
     - 輸入 `s`：如果當前字根 + `s` 不在字典中，但當前字根存在且候選字數量 >= 4，則選擇候選4（第4個候選字），等待 Space 鍵送出
     - 輸入 `f`：如果當前字根 + `f` 不在字典中，但當前字根存在且候選字數量 >= 5，則選擇候選5（第5個候選字），等待 Space 鍵送出
     - 輸入 `w`：如果當前字根 + `w` 不在字典中，但當前字根存在且候選字數量 >= 6，則選擇候選6（第6個候選字），等待 Space 鍵送出
     - 補碼選擇後不會立即送出，需要按 Space 鍵才會送出選中的候選字
     - **觸發條件**：
       - 如果當前字根 + 補碼長度 < 5：檢查是否有以該組合開頭的更長字根；如果沒有，則觸發補碼；如果有，則不觸發（讓用戶繼續輸入）
       - 如果當前字根 + 補碼長度 = 5：如果不在字典中，則觸發補碼（因為無法繼續輸入更長的字根）
   - **符號輸入**：
     - 輸入符號（例如點號 `.` 或逗號 `,`）：有兩種情況
       - 如果當前有字根，查找 字根+符號 的組合（例如 `s.` 對應 `？`）
       - 如果當前沒有字根，查找單獨符號（例如 `.` 對應 `。`，`,` 對應 `，`）
     - 符號映射在字典中定義，例如：
       - `s.` 對應 `？`（問號）
       - `.` 對應 `。`（句號）
       - `,` 對應 `，`（逗號）
     - 符號選擇後不會立即送出，需要按 Space 鍵才會送出選中的符號

3. **特殊按鍵**
   - Backspace：刪除最後一個字根
   - ESC：清除當前輸入
   - Shift：切換攔截模式（按下後切換到不攔截模式，只攔截 Shift 鍵本身，其他按鍵通過；再按一次恢復攔截模式；切換時會清除現有字根）
     - **注意**：Shift 鍵只用來切換攔截模式，不影響輸出的大小寫。輸出的大小寫只由 CapsLock 狀態決定：
       - CapsLock OFF → 小寫
       - CapsLock ON → 大寫
     - **英模式 = 不攔截模式**：當 Shift 切換到不攔截模式時，就是英模式，所有按鍵都會通過
   - **Ctrl 組合鍵支援**：當 Ctrl 鍵按下時，所有後續按鍵都會讓事件通過，確保 Ctrl+C、Ctrl+V、Ctrl+A 等組合鍵能正常工作
     - 這與 Python 版本的實現一致，確保在攔截模式下也能正常使用 Ctrl 組合鍵
   - Space：選擇第一個候選字並清除輸入
   - Enter：選擇第一個候選字並清除輸入（與 Space 行為一致）
   - F4：退出程式（無論是攔截模式還是不攔截模式，都能退出）
   - 系統托盤退出選項：點擊系統托盤圖示的「退出」選項，行為與 F4 鍵完全一致（設置退出標誌並調用 PostQuitMessage）

4. **攔截模式行為**
   - **攔截模式（肥米模式）**：`shift_toggle` 為 `false` 時，所有未明確處理的按鍵都會被攔截，不只是英文字母
     - 符號、標點符號等所有可列印字符都會被攔截
     - 功能鍵會讓事件通過（不攔截）：
       - F1-F24、方向鍵、Tab、CapsLock、NumLock、ScrollLock
       - Home、End、PageUp、PageDown、Insert、Delete
       - PrintScreen、Pause、Win鍵、Alt、Menu鍵
   - **不攔截模式（英模式）**：`shift_toggle` 為 `true` 時，所有按鍵都會通過，不進行任何處理
     - 英模式就是不攔截模式，通過 Shift 鍵切換
     - 在英模式下，可以正常輸入英文和符號

5. **輸入模式**
   - 目前實作剪貼簿貼上模式（**推薦用於遊戲環境**）
     - 兼容性最高，幾乎所有遊戲都支援 Ctrl+V 貼上
     - 不容易被反作弊系統檢測
     - 模擬真實用戶操作，符合用戶習慣
   - 待實作：直接輸入模式（用於非遊戲環境，速度更快）、Big5 模式
   - 詳細說明請參考 [GAME_INPUT_COMPATIBILITY.md](GAME_INPUT_COMPATIBILITY.md)

### 下一步開發重點

1. GUI 介面（候選字視窗顯示）
2. 模式切換（肥/英、半/全）
3. 多種輸入模式（直接輸入、Big5 模式）
4. 特殊應用程式處理（putty、notepad 等）

## 參考資料

- [Windows API 文件](https://docs.microsoft.com/en-us/windows/win32/api/)
- [windows-rs](https://github.com/microsoft/windows-rs)
- [enigo](https://github.com/enigo-rs/enigo)

